(import (chicken bitwise) (chicken condition) (chicken file posix) 
        (chicken foreign) (chicken io) (chicken string) (srfi 4))

(define-syntax λ (syntax-rules () ((_ . ω) (lambda . ω))))
(define-syntax ? (syntax-rules () ((_ . ω) (if . ω))))
(define-syntax ← (syntax-rules () ((_ . ω) (define . ω))))
(define-syntax ∃ (syntax-rules () ((_ . ω) (let* . ω))))
(define-syntax either
  (syntax-rules ()
    ((_ f ...)
     (∃ ((ω (condition-case ((λ () f ...))
              (e (exn) (left (get-condition-property e 'exn 'message))))))
       (? (left? ω) ω (right ω))))))
(define-syntax for
  (syntax-rules (←)
    ((_ (← α β) ω Ω ...) (>>= (λ (α) (for ω Ω ...)) β))
    ((_ (  α β) ω Ω ...) (>>= (λ (α) (for ω Ω ...)) (right β)))
    ((_               ω) (right ω))))

(← NRPN-CMDS '((p1 0   0 63 64)
               (l1 1 -63 63 64)
               (y  2   0  3 64)
               (q1 3   0 63 64)))

(← ↑ car) (← ↓ cdr) (← ↑↓ cadr) (← ∘ compose) (← ≡ equal?) (← ∅ '()) 
(← ∅? null?) (← ρ length) (← ◇ conc) (← ⊂ cons) (← ∀ map) (← $ apply)
(← (∧ ω α) (and ω α))
(← (∨ ω α) (or ω α))
(← (I ω) ω)
(← (K ω) (λ (α) ω))
(← (C f) (λ (ω) (λ (α) (f ω α))))
(← (S g f) (λ (ω) (g ω (f ω))))
(← (J h g f) (λ (ω) (h (g ω) (f ω))))
(← (right ω) `(R ,ω))
(← (left ω) `(L ,ω))
(← (right? ω) (? (list? ω) (? (≡ 2 (ρ ω)) (≡ 'R (↑ ω)) #f) #f))
(← (left? ω) (? (list? ω) (? (≡ 2 (ρ ω)) (≡ 'L (↑ ω)) #f) #f))
(← (either? ω) (? ((J ∨ left? right?) ω) ω (left (◇ "not an either: " ω))))
(← (get Fω) (? (right? Fω) (↑↓ Fω) (error (↑↓ Fω))))
(← (⊙ f Fω) (∃ ((α (either? Fω))) (? (right? α) (right (f (↑↓ α))) α)))
(← (_⊙ f Fω) (∃ ((α (either? Fω))) (? (left? α) (left (f (↑↓ α))) α)))
(← (⊙⊙ f g Fω) (⊙ f (_⊙ g Fω)))
(← (⊥ Fω) (either (get (get Fω))))
(← (>>= f Fω) (⊥ (⊙ f Fω)))
(← (● Ff Fω) (>>= (λ (ω) (⊙ (λ (f) (f ω)) Ff)) Fω))
(← (*> Fω Fα) (>>= (K Fα) Fω))
(← ($> Fω α) (*> Fω (right α)))
(← (lift2 f Fα Fω) (● (⊙ (C f) Fα) Fω))
(← (sequence Fω) (foldr (λ (x acc) (lift2 ⊂ x acc)) (right ∅) Fω))
(← (break △ Fω) (? (left? Fω) (△ Fω) Fω))
(← (traverse f Fω) (call/cc (λ (△) (sequence (∀ (∘ ((C break) △) f) Fω)))))
(← (ι n Fω) (either (list-ref Fω n)))
(← (ensure p e ω) (? p (right ω) (left e)))
(← (s⊥ f e ω) (>>= (λ (α) (ensure α (◇ e ": " ω) α)) (either (f ω))))
(← (s⊥n ω) (s⊥ string->number "not number" ω))
(← (s⊥x ω) (s⊥ string->symbol "not symbol" ω))
(← (∈ ω k) (∃ ((α (assoc k ω))) (⊙ ↓ (ensure α (◇ "cmd not found: " k) α))))
(← ∈-nrpn ((C ∈) NRPN-CMDS))
(← (nrpn ω) (for (← _ (ensure (≡ 2 (ρ ω)) ($ ◇ `("invalid arg count: " ,ω)) ∅))
                 (← cmd-str (ι 0 ω))
                 (← val-str (ι 1 ω))
                 (← cmd-sym (s⊥x cmd-str))
                 (← val (s⊥n val-str))
                 (← cmd (∈-nrpn cmd-sym))
                 (← cmd-byte (ι 0 cmd))
                 (← min (ι 1 cmd))
                 (← max (ι 2 cmd))
                 (← offset (ι 2 cmd))
                 (← _ (ensure (>= val min) (◇ val " < " min) ∅)) 
                 (← _ (ensure (<= val max) (◇ val " > " max) ∅))
                 `(,cmd-byte ,(+ offset val))))


; scratch
(traverse s⊥n (list "1" '() "3" "4"))
(∈-nrpn 'p2)
(∈ NRPN-CMDS 'p1)
(nrpn '("l1" "q"))
